---
title: "drone-based-model"
output: html_document
date: "2023-12-25"
---

## Load packages

```{r, warning=FALSE}
library(glmnet)
library(raster)
library(tidyverse)
library(glue)
library(ggtern)
library(jsonlite)
library(sf)
library(stars)
```


## Generate features of orthomosaic to build our formula

```{r, warning=FALSE}
ortho_path <- 'raw_data/ortho.tif'
ndvi_path <- 'clean_data/ndvi.tif'
processed_ortho_path <- 'clean_data/processed_ortho.tif'

ortho <- terra::rast(ortho_path)
ndvi <- terra::rast(ndvi_path)
processed_ortho <-terra::rast(processed_ortho_path)
```

## Extract data

orthomosaic data

```{r}
corner_points <- st_read("/media/DataSSD1/data/quadClassify/raw_data/drone_sitched/coord_layer.shp") |>
  rename(quadrat = id) |>
  mutate(quadrat = as.character(quadrat)) |>
  as_tibble()

quadrants <- corner_points |> 
  pivot_wider(names_from = corner,  values_from = geometry, names_prefix = "corner_") |>
  rowwise() |>
  mutate(zero = create_quadrant_polygon(0, corner_c, corner_i, corner_ii),
         one = create_quadrant_polygon(1,  corner_c, corner_i, corner_ii),
         two = create_quadrant_polygon(2, corner_c, corner_i, corner_ii),
         three = create_quadrant_polygon(3,  corner_c, corner_i, corner_ii)
  ) |>
  ungroup() |>
  dplyr::select(c(quadrat, zero, one, two, three)) |>
  pivot_longer(cols = c(zero, one, two, three), names_to = "quadrant", values_to = "geometry") |>
  mutate(quadrant_key = paste(quadrat, quadrant, sep = "_")) |>
  rename(polygon = geometry)

ortho_data <- quadrants |>
  rowwise() |>
  mutate(aggregates = terra::extract(processed_ortho, polygon[[1]])) |>
  dplyr::select(c(quadrant_key, aggregates)) |>
  ungroup() |>
  unnest(cols = aggregates)
ortho_data
```

quadrat data

```{r}
corner_points <- tibble(json_path = sprintf("raw_data/quadrats/quadrat%02d/points.json", seq(34, 83, 1)))

model_name <- 'xgb_fit'
image_files <-tibble(classified = list.files(glue('clean_data/classified/{model_name}')[[1]], pattern ='.tif', full.names = TRUE))
num_image_files <-length(image_files$classified)

data <- bind_cols(corner_points[1:num_image_files,], image_files) |>
  mutate(quadrat = gsub("\\D", "", classified)) |>
  rowwise() |>
  mutate(polygon = list(label_me_points_json_to_sf(json_path))) |>
  ungroup() |>
  unnest(cols = polygon) 

geometry <- data |>
  dplyr::select(quadrat, corner, points) |>
  pivot_wider(names_from = corner,  values_from = points, names_prefix = "corner_")

image_key <- dplyr::select(data, c(quadrat, classified)) |>
  group_by(quadrat) |>
  slice(1) |>
  ungroup()

ground_quadrants <- geometry |>
  rowwise() |>
  mutate(zero = create_quadrant_polygon(0, corner_c, corner_i, corner_ii),
         one = create_quadrant_polygon(1,  corner_c, corner_i, corner_ii),
         two = create_quadrant_polygon(2, corner_c, corner_i, corner_ii),
         three = create_quadrant_polygon(3,  corner_c, corner_i, corner_ii)) |>
  ungroup() |>
  dplyr::select(c(quadrat, zero, one, two, three)) |>
  pivot_longer(cols = c(zero, one, two, three), names_to = "quadrant", values_to = "geometry") |>
  mutate(quadrant_key = paste(quadrat, quadrant, sep = "_")) |>
  left_join(image_key, by = 'quadrat') |>
  rowwise() |>
  mutate(polys = list(scale_polygon(geometry))) |>
  ungroup() |>
  dplyr::select(-geometry) |>
  nest(polys= c(quadrant, polys, quadrant_key)) |>
  rowwise() |>
  mutate(polys = list(st_as_sf(polys))) |>
  ungroup()

ground_quadrants[1,]$polys[[1]]
```

```{r}
ground_data <- ground_quadrants |>
  rowwise() |>
  mutate(aggregates = list(extract_polygon_pixels(classified, polygon = polys, extent = c(0,1,0,1), include_polygon_info = TRUE) )) |>
  ungroup() 

data <- bind_rows(ground_data$aggregates) |>
  rename(class = lyr1) |>
  dplyr::select(c(class, quadrant_key)) |>
  group_by(quadrant_key, class) |>
  summarise(n = n()) |>
   pivot_wider(
    names_from = class, 
    values_from = n,
    names_prefix = "class_"
  )
data
```


## Load the data

```{r}
counts_path <- "clean_data/quad_data_xgb_wf_best_10_17_23.rds"

pixel_counts <- readRDS(counts_path)  |>
  mutate(notgrass = dead + sand)

pixel_counts
```


## Set the seed and split data

```{r}
set.seed(8675309)

training_split <- pixel_counts |> 
  initial_split(strata = grass)

counts_train <- training_split |>
  training()

counts_test <- training_split |>
  testing()
```


Multinomial regression model with lasso regularization.

```{r}
non_predictors <- c("notgrass", "grass", "sand", "dead", "quadrat", "total", "quad_num","quad_quad")
predictors <- names(pixel_counts)[!names(pixel_counts) %in% non_predictors]
```


Formulate response and predictors

```{r}
y <- counts_train |>
  dplyr::select(c(grass, sand, dead)) |>
  as.matrix()

x <- counts_train |>
  dplyr::select(predictors) |>
  as.matrix()
```


Fit the model with cross validation

```{r}
fit <- cv.glmnet(x, y , family = "multinomial", type.multinomial = "grouped")
```

## Save fit

```{r}
multinomial_fit <- fit
saveRDS(multinomial_fit, 'clean_data/mutlinomial_fit.rds')
```


## Plot the object fit 

```{r}
plot(fit)
```

```{r}
options(scipen = 999)
coefficients <- coef(fit, s = "lambda.min")
coefficients
```

## Test response

```{r}
test_y <- counts_test |>
  dplyr::select(c(grass, sand, dead)) |>
  rowwise() |>
  mutate(total = sum(grass, sand, dead)) |>
  mutate(dead.obs = dead/total,
         grass.obs = grass/total,
         sand.obs = sand/total) |>
  dplyr::select(-c(total, grass, dead, sand)) |>
  ungroup()
  

test_x <- counts_test |>
  dplyr::select(predictors) |>
  as.matrix()

prediction <- predict(fit, newx = test_x, s = "lambda.min", type = 'response') |>
  as_tibble() |>
  rename(dead.pred = dead.1, grass.pred = grass.1, sand.pred = sand.1)
```

Extract test RMSE

```{r}
n  <- nrow(test_y)

error <- bind_cols(prediction, test_y) |>
  pivot_longer(everything(), names_to = c("type", ".value"), names_sep = "\\.") |>
  rowwise() |>
  mutate(squard_error = (pred -obs)^2) |>
  ungroup()

rmse <- sqrt(sum(error$squard_error)/n)

print('Total root mean squared error')
print(rmse)
```


Plot on ternary diagram

```{r}
error |> 
  ggplot(aes(obs, pred, color = type)) +
  geom_point() +
  geom_abline() +
  theme_minimal()
```


```{r}
data <- bind_cols(prediction, test_y) |>
  dplyr::select(dead.obs, grass.obs, sand.obs, dead.pred, grass.pred, sand.pred) |>
  mutate(id = 1:nrow(prediction)) |>
  pivot_longer(ends_with(c("obs","pred")), names_to = c(".value", "type"), names_sep = "\\.") 
data
```

```{r Ternary with points}
data |>
  ggtern(aes(dead, grass, sand, group = id)) +
  geom_point() +
  theme_rgbw()
```

```{r Ternary with arrows}
data |>
  ggtern(aes(dead, grass, sand, group = id)) +
  geom_path(arrow = arrow(length = unit( 0.05, "inches"))) +
  theme_rgbw()
```


